"""
Comprehensive tests for AsyncNotionClient.

Tests session management, connection pooling, error handling, 
singleton behavior, and security features.
"""
import asyncio
import ssl
from unittest.mock import AsyncMock, MagicMock, patch

import aiohttp
import pytest

from notion_task_runner.notion.async_notion_client import AsyncNotionClient
from notion_task_runner.tasks.task_config import TaskConfig
from notion_task_runner.logging import configure_logging

# Configure logging for tests
configure_logging(json_logs=False, log_level="DEBUG")


@pytest.fixture
def mock_config():
    """Create a mock config with valid values."""
    config = MagicMock(spec=TaskConfig)
    config.notion_token_v2 = "valid_token_123456789"
    config.notion_api_key = "secret_api_key_123456789"
    config.notion_space_id = "space_id_123456789"
    return config


@pytest.fixture
def clean_singleton():
    """Ensure singleton is reset before and after tests."""
    import asyncio
    asyncio.run(AsyncNotionClient.reset_singleton())
    yield
    asyncio.run(AsyncNotionClient.reset_singleton())


class TestAsyncNotionClientSingleton:
    """Test singleton pattern behavior."""

    @pytest.mark.asyncio
    async def test_singleton_creation(self, mock_config, clean_singleton):
        """Test that singleton pattern works correctly."""
        client1 = AsyncNotionClient(mock_config)
        client2 = AsyncNotionClient(mock_config)
        
        assert client1 is client2
        assert AsyncNotionClient._instance is client1

    @pytest.mark.asyncio
    async def test_singleton_with_none_config(self, clean_singleton):
        """Test singleton creation with None config."""
        with patch('notion_task_runner.tasks.task_config.TaskConfig.from_env') as mock_from_env:
            mock_from_env.return_value = MagicMock(
                notion_token_v2="valid_token_123456789",
                notion_api_key="secret_api_key_123456789", 
                notion_space_id="space_id_123456789"
            )
            
            client = AsyncNotionClient(None)
            mock_from_env.assert_called_once()
            assert client is not None

    @pytest.mark.asyncio
    async def test_singleton_reset(self, mock_config, clean_singleton):
        """Test singleton reset functionality."""
        client = AsyncNotionClient(mock_config)
        assert AsyncNotionClient._instance is client
        
        await AsyncNotionClient.reset_singleton()
        assert AsyncNotionClient._instance is None
        assert not AsyncNotionClient._initialized

    @pytest.mark.asyncio
    async def test_singleton_thread_safety(self, mock_config, clean_singleton):
        """Test thread safety of singleton creation."""
        clients = []
        
        async def create_client():
            client = AsyncNotionClient(mock_config)
            clients.append(client)
        
        # Create multiple clients concurrently
        await asyncio.gather(*[create_client() for _ in range(5)])
        
        # All should be the same instance
        assert all(client is clients[0] for client in clients)


class TestConfigurationValidation:
    """Test configuration validation and security."""

    @pytest.mark.asyncio
    async def test_valid_config_validation(self, mock_config, clean_singleton):
        """Test that valid config passes validation."""
        # Should not raise any exception
        client = AsyncNotionClient(mock_config)
        assert client.config == mock_config

    @pytest.mark.asyncio
    async def test_invalid_token_length(self, clean_singleton):
        """Test validation of token length."""
        config = MagicMock(spec=TaskConfig)
        config.notion_token_v2 = "short"  # Too short
        config.notion_api_key = "secret_api_key_123456789"
        config.notion_space_id = "space_id_123456789"
        
        with pytest.raises(ValueError, match="Invalid or missing Notion token_v2"):
            AsyncNotionClient(config)

    @pytest.mark.asyncio
    async def test_invalid_api_key_length(self, clean_singleton):
        """Test validation of API key length."""
        config = MagicMock(spec=TaskConfig)
        config.notion_token_v2 = "valid_token_123456789"
        config.notion_api_key = "short"  # Too short
        config.notion_space_id = "space_id_123456789"
        
        with pytest.raises(ValueError, match="Invalid or missing Notion API key"):
            AsyncNotionClient(config)

    @pytest.mark.asyncio
    async def test_suspicious_characters_in_token(self, clean_singleton):
        """Test detection of suspicious characters in tokens."""
        config = MagicMock(spec=TaskConfig)
        config.notion_token_v2 = "token_with_<script>_123456789"  # Contains suspicious chars
        config.notion_api_key = "secret_api_key_123456789"
        config.notion_space_id = "space_id_123456789"
        
        with pytest.raises(ValueError, match="potentially unsafe characters"):
            AsyncNotionClient(config)

    @pytest.mark.asyncio
    async def test_empty_space_id(self, clean_singleton):
        """Test validation of empty space ID."""
        config = MagicMock(spec=TaskConfig)
        config.notion_token_v2 = "valid_token_123456789"
        config.notion_api_key = "secret_api_key_123456789"
        config.notion_space_id = ""  # Empty
        
        with pytest.raises(ValueError, match="Invalid or missing Notion space ID"):
            AsyncNotionClient(config)


class TestSessionManagement:
    """Test session creation and management."""

    @pytest.mark.asyncio
    async def test_session_creation(self, mock_config, clean_singleton):
        """Test that session is created properly."""
        client = AsyncNotionClient(mock_config)
        
        with patch.object(client, '_session', None):
            with patch('aiohttp.ClientSession') as mock_session_class:
                with patch('aiohttp.TCPConnector') as mock_connector_class:
                    mock_connector = MagicMock()
                    mock_connector_class.return_value = mock_connector
                    
                    mock_session = MagicMock()
                    mock_session_class.return_value = mock_session
                    
                    # Mock the POST request for user content
                    mock_response = AsyncMock()
                    mock_response.raise_for_status = MagicMock()
                    mock_response.json = AsyncMock(return_value={
                        "recordMap": {
                            "notion_user": {"user123": {}}
                        }
                    })
                    mock_session.post.return_value.__aenter__ = AsyncMock(return_value=mock_response)
                    mock_session.post.return_value.__aexit__ = AsyncMock()
                    
                    await client._ensure_session()
                    
                    # Verify connector was created with security settings
                    mock_connector_class.assert_called_once()
                    connector_kwargs = mock_connector_class.call_args[1]
                    assert connector_kwargs['verify_ssl'] is True
                    assert connector_kwargs['limit'] == 100
                    assert connector_kwargs['limit_per_host'] == 30

    @pytest.mark.asyncio
    async def test_session_creation_failure(self, mock_config, clean_singleton):
        """Test handling of session creation failure."""
        client = AsyncNotionClient(mock_config)
        
        with patch.object(client, '_session', None):
            with patch('aiohttp.ClientSession') as mock_session_class:
                mock_session_class.side_effect = Exception("Connection failed")
                
                with pytest.raises(Exception, match="Connection failed"):
                    await client._ensure_session()

    @pytest.mark.asyncio
    async def test_session_already_exists(self, mock_config, clean_singleton):
        """Test that existing session is not recreated."""
        client = AsyncNotionClient(mock_config)
        
        # Mock an existing session
        mock_session = MagicMock()
        client._session = mock_session
        
        with patch('aiohttp.ClientSession') as mock_session_class:
            await client._ensure_session()
            
            # Should not create new session
            mock_session_class.assert_not_called()


class TestHTTPMethods:
    """Test HTTP request methods."""

    @pytest.fixture
    async def client_with_session(self, mock_config, clean_singleton):
        """Create client with mocked session."""
        client = AsyncNotionClient(mock_config)
        
        # Mock session
        mock_session = AsyncMock()
        client._session = mock_session
        
        return client, mock_session

    @pytest.mark.asyncio
    async def test_post_request_success(self, client_with_session):
        """Test successful POST request."""
        client, mock_session = await client_with_session
        
        # Mock successful response
        mock_response = MagicMock()
        mock_response.json = AsyncMock(return_value={"success": True})
        mock_session.post.return_value.__aenter__ = AsyncMock(return_value=mock_response)
        mock_session.post.return_value.__aexit__ = AsyncMock()
        
        # Mock response error handling
        with patch.object(client, '_handle_response_errors') as mock_handle_errors:
            result = await client.post("https://test.com", json={"test": "data"})
            
            assert result == {"success": True}
            mock_session.post.assert_called_once()
            mock_handle_errors.assert_called_once()

    @pytest.mark.asyncio
    async def test_post_request_with_data(self, client_with_session):
        """Test POST request with string data."""
        client, mock_session = await client_with_session
        
        mock_response = MagicMock()
        mock_response.json = AsyncMock(return_value={"data": "received"})
        mock_session.post.return_value.__aenter__ = AsyncMock(return_value=mock_response)
        mock_session.post.return_value.__aexit__ = AsyncMock()
        
        with patch.object(client, '_handle_response_errors'):
            result = await client.post("https://test.com", data="test data")
            
            assert result == {"data": "received"}

    @pytest.mark.asyncio
    async def test_get_request_success(self, client_with_session):
        """Test successful GET request."""
        client, mock_session = await client_with_session
        
        mock_response = MagicMock()
        mock_session.get.return_value = mock_response
        
        with patch.object(client, '_handle_response_errors'):
            result = await client.get("https://test.com")
            
            assert result == mock_response
            mock_session.get.assert_called_once_with("https://test.com", headers=None)

    @pytest.mark.asyncio
    async def test_get_request_with_headers(self, client_with_session):
        """Test GET request with custom headers."""
        client, mock_session = await client_with_session
        
        mock_response = MagicMock()
        mock_session.get.return_value = mock_response
        
        headers = {"Authorization": "Bearer token"}
        
        with patch.object(client, '_handle_response_errors'):
            result = await client.get("https://test.com", headers=headers)
            
            assert result == mock_response
            mock_session.get.assert_called_once_with("https://test.com", headers=headers)

    @pytest.mark.asyncio
    async def test_patch_request_success(self, client_with_session):
        """Test successful PATCH request."""
        client, mock_session = await client_with_session
        
        mock_response = MagicMock()
        mock_session.patch.return_value.__aenter__ = AsyncMock(return_value=mock_response)
        mock_session.patch.return_value.__aexit__ = AsyncMock()
        
        with patch.object(client, '_handle_response_errors'):
            result = await client.patch("https://test.com", json={"update": "data"})
            
            assert result == mock_response
            mock_session.patch.assert_called_once()

    @pytest.mark.asyncio
    async def test_delete_request_success(self, client_with_session):
        """Test successful DELETE request."""
        client, mock_session = await client_with_session
        
        mock_response = MagicMock()
        mock_session.delete.return_value.__aenter__ = AsyncMock(return_value=mock_response)
        mock_session.delete.return_value.__aexit__ = AsyncMock()
        
        with patch.object(client, '_handle_response_errors'):
            result = await client.delete("https://test.com")
            
            assert result == mock_response
            mock_session.delete.assert_called_once()


class TestErrorHandling:
    """Test error handling and response validation."""

    @pytest.fixture
    async def client_with_session(self, mock_config, clean_singleton):
        """Create client with mocked session."""
        client = AsyncNotionClient(mock_config)
        client._session = AsyncMock()
        return client

    @pytest.mark.asyncio
    async def test_handle_response_errors_success(self, client_with_session):
        """Test error handler with successful response."""
        client = await client_with_session
        
        mock_response = MagicMock()
        mock_response.status = 200
        mock_response.raise_for_status = MagicMock()
        
        # Should not raise any exception
        await client._handle_response_errors(mock_response, "GET", "https://test.com")
        mock_response.raise_for_status.assert_called_once()

    @pytest.mark.asyncio
    async def test_handle_response_errors_client_error(self, client_with_session):
        """Test error handler with client error."""
        client = await client_with_session
        
        mock_response = MagicMock()
        mock_response.status = 400
        mock_response.text = AsyncMock(return_value="Bad Request")
        mock_response.raise_for_status = MagicMock(side_effect=aiohttp.ClientResponseError(
            request_info=MagicMock(),
            history=(),
            status=400
        ))
        
        with pytest.raises(aiohttp.ClientResponseError):
            await client._handle_response_errors(mock_response, "POST", "https://test.com")

    @pytest.mark.asyncio
    async def test_request_exception_handling(self, client_with_session):
        """Test exception handling in requests."""
        client = await client_with_session
        client._session.post.side_effect = aiohttp.ClientError("Connection error")
        
        with pytest.raises(aiohttp.ClientError, match="Connection error"):
            await client.post("https://test.com")


class TestContextManager:
    """Test async context manager functionality."""

    @pytest.mark.asyncio
    async def test_context_manager_enter_exit(self, mock_config, clean_singleton):
        """Test async context manager."""
        client = AsyncNotionClient(mock_config)
        
        with patch.object(client, '_ensure_session') as mock_ensure:
            with patch.object(client, 'close') as mock_close:
                async with client as ctx_client:
                    assert ctx_client is client
                    mock_ensure.assert_called_once()
                
                mock_close.assert_called_once()


class TestCleanup:
    """Test resource cleanup and sensitive data handling."""

    @pytest.mark.asyncio
    async def test_close_with_session(self, mock_config, clean_singleton):
        """Test closing with active session."""
        client = AsyncNotionClient(mock_config)
        
        # Mock session and connector
        mock_session = AsyncMock()
        mock_session.closed = False
        mock_session.close = AsyncMock()
        
        mock_connector = AsyncMock()
        mock_connector.close = AsyncMock()
        
        client._session = mock_session
        client._connector = mock_connector
        client.config = mock_config
        
        await client.close()
        
        # Verify cleanup
        mock_session.close.assert_called_once()
        mock_connector.close.assert_called_once()
        assert client.config is None

    @pytest.mark.asyncio
    async def test_close_with_closed_session(self, mock_config, clean_singleton):
        """Test closing with already closed session."""
        client = AsyncNotionClient(mock_config)
        
        mock_session = AsyncMock()
        mock_session.closed = True
        mock_session.close = AsyncMock()
        
        client._session = mock_session
        
        await client.close()
        
        # Should not try to close already closed session
        mock_session.close.assert_not_called()

    @pytest.mark.asyncio
    async def test_close_without_session(self, mock_config, clean_singleton):
        """Test closing without session."""
        client = AsyncNotionClient(mock_config)
        
        # Should not raise exception
        await client.close()


class TestSecurityFeatures:
    """Test security-related features."""

    @pytest.mark.asyncio
    async def test_ssl_verification_enabled(self, mock_config, clean_singleton):
        """Test that SSL verification is enabled."""
        client = AsyncNotionClient(mock_config)
        
        # Test that _create_authenticated_session would use verify_ssl=True
        with patch('aiohttp.TCPConnector') as mock_connector_class:
            with patch('aiohttp.ClientSession') as mock_session_class:
                with patch('aiohttp.CookieJar'):
                    # Mock the session.post call to avoid actual network request
                    mock_session = AsyncMock()
                    mock_session.post.return_value.__aenter__ = AsyncMock()
                    mock_session.post.return_value.__aexit__ = AsyncMock()
                    mock_session.post.return_value.__aenter__.return_value.json = AsyncMock(
                        return_value={"recordMap": {"notion_user": {"user123": {}}}}
                    )
                    mock_session.post.return_value.__aenter__.return_value.raise_for_status = AsyncMock()
                    mock_session_class.return_value = mock_session
                    
                    try:
                        await client._create_authenticated_session()
                    except Exception:
                        pass  # We expect this to fail due to mocking, but we can check the connector args
                    
                    # Verify SSL verification is enabled
                    if mock_connector_class.called:
                        connector_kwargs = mock_connector_class.call_args[1]
                        assert connector_kwargs['verify_ssl'] is True

    @pytest.mark.asyncio
    async def test_trust_env_disabled(self, mock_config, clean_singleton):
        """Test that trusting environment is disabled for security."""
        client = AsyncNotionClient(mock_config)
        
        # Test that _create_authenticated_session would use trust_env=False
        with patch('aiohttp.ClientSession') as mock_session_class:
            with patch('aiohttp.TCPConnector'):
                with patch('aiohttp.CookieJar'):
                    # Mock the session.post call to avoid actual network request
                    mock_session = AsyncMock()
                    mock_session.post.return_value.__aenter__ = AsyncMock()
                    mock_session.post.return_value.__aexit__ = AsyncMock()
                    mock_session.post.return_value.__aenter__.return_value.json = AsyncMock(
                        return_value={"recordMap": {"notion_user": {"user123": {}}}}
                    )
                    mock_session.post.return_value.__aenter__.return_value.raise_for_status = AsyncMock()
                    mock_session_class.return_value = mock_session
                    
                    try:
                        await client._create_authenticated_session()
                    except Exception:
                        pass  # We expect this to fail due to mocking, but we can check the session args
                    
                    # Verify trust_env is disabled
                    if mock_session_class.called:
                        session_kwargs = mock_session_class.call_args[1]
                        assert session_kwargs['trust_env'] is False